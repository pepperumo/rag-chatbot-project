## FEATURE:

Let's build an AI agent with Pydantic AI and LangGraph. Build a LangGraph workflow with Pydantic AI to demonstrate LLM routing. A request comes into the flow -> e have a node at the start of the graph to make a simple call to an LLM. This can just be a Pydantic AI agent with no tools. And we want it to be a different LLM than the one that's going to be used for the rest of the agents because it's going to be more of a lightweight LLM like GPT 4.1 Nano instead of GPT 4.1 Mini, for example. This LLM is just going to evaluate the user question or request based on a system prompt that tells it how to determine the agent to route to, which are all going to be Pydantic AI agents. This whole workflow is going to be research-based. I need one Pydantic AI agent that is responsible for web search with the Brave API, one that's responsible for searching the inbox with Gmail, and then another that is responsible for searching the documents that we have in our knowledge base with RAG. And so the system prompt for the routing LLM has to include all the information it would need to know, like based on the user question, which of the agents should I go to. And then there should be a fallback if the request doesn't actually match with any of these sub-agents, then we just want to route to a fallback. And it's just going to give some messages to the user saying that like hey, this is not a valid request. So you just have a specific node in LaneGraph specifically for being the fallback node. All of these agents need to have streaming with the .iter function and will each be at the end of the graph. So the graph will end after one of these agents or the fallback node. 

It is absolutely crucial that you dive deep into the other two folders that we have here: 7.3-Multi-Agent-Intro and 7.4-LangraphAgentWithGuardrail. Because you're going to be pulling directly from these implementations for basically everything that you're doing. In fact, the current folder structure is the same right now as 7.4-LangraphAgentWithGuardrail. You just have to tweak everything to work with this new LLM routing workflow. 

So, you're going to be changing a lot of existing files here and creating some new ones for the new agents. And so, we don't want any remnant of the old workflow specific to the LangGraph agent with Guardrail. It all has to be completely overhauled, like a lot of changes that you're going to be making here to make it so that it's for this new LLM routing workflow. 

## EXAMPLES AND DOCUMENTATION:

7.3-MultiAgentIntro - see the agents in here for Gmail and web research with the Brave API. The Gmail agent here doesn't have the ability to read through past emails. So you're just going to have to use this as a reference for how to bring Gmail into an agent. But then you'll have to tweak this, obviously, to have some tools like view past emails because this is a research-based agent. We're not going to be writing drafts. We're not just going to be reading emails because that's going to be one of the ways we can research information based on the user request.

7.4-LangGraphAgentWithGuardrail - This is the template in which our current directory is based off of. Just so that you know exactly how to set up an API endpoint to work with LangGraph, how to build the LangGraph workflows, how to work with the user input, how to set up the different nodes, how to create the Pydantic AI agents, this is your reference point. And so you still need to completely overhaul things, just using this as your inspiration, as your structure, as your guidance and documentation. Obviously, a lot is different here because we have different agents. We have a different flow for LangGraph. I will say, though, that the API endpoint will remain pretty much the same. And so it's still important for you to read through all of the files that we have here to understand the agents and the workflows and also to understand the testing and the API. But the API, you probably won't have to change that much. Most of the things, though, including the README, you're going to have to do a very big overhaul on, just using what we already have as your starting point. 

## OTHER CONSIDERATIONS:

- Update the project structure in the README and basically do a big overhaul of the README after overhauling the existing codebase for the new graph.
- Virtual environment has already been set up with the necessary dependencies.
- .env.example has already been set up with all necessary values/credentials.
- Use python_dotenv and load_env() for environment variables.
